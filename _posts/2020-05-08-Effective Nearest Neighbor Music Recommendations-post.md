---
layout: post
title: Effective Nearest-Neighbor Music Recommendations
author: Jaeheon Kwon
categories: Papers
tags: [recommendation,knn]
---

#  Effective Nearest-Neighbor Music Recommendations  

## Abstract

<hr>

다음 트랙이 재생목록에 포함되거나 포함되도록 자동으로 추천하는 시스템은 최신 음악 플랫폼에서 일반적인 기능입니다.

이에 따라, 추천할 트랙을 결정하기 위한 다양한 알고리즘이 연구를 통해 제안되었습니다.

그 중에서 높은 성능을 보이는 것들은 종종 개념적으로 복잡한 테크닉을 기반으로 하며, 상당한 컴퓨팅 리소스 혹은 GPU같은 특수 목적 하드웨어를 필요로합니다.

그러나 최근 연구에 따르면, Nearest-Neighbor를 기반으로 하는 개념적으로 더 간단한 기법은 실제로 위의 기술들의 대안이 될 수 있음이 밝혀졌습니다.

이 논문에서는 RecSys 2018 Challenge에서 평가된 다음 트랙 추천을 위한 하이브리드 테크닉에 대해 설명합니다.

K-NN, standard matrix factorization, small set of heuristics를 조합하여 "creative" 트랙에서 3위, "main"트랙에서 7위를 달성했습니다.

## Introduction

<hr>

자동 추천기능을 지원하는 것은 온라인 음악 플랫폼들의 공통 기능입니다.

장기적인 환경 설정을 기반으로하며 사용자가 새로운 트랙이나 아티스트를 찾도록 돕기위한 추천 시스템 외에도 다음 트랙을 추천하는 것은 이러한 플랫폼에서 중요한 역할을 합니다.

문제 설정의 측면에서 다음 트랙을 추천하는 것은 종종 세션 기반의 추천 시나리오의 특성을 공유합니다.( In terms of the problem setting, these next-track recommendations often share characteristics of session-based recommendation scenarios )

이 시나리오의 특징은 사용 가능한 장기 환경 설정 프로필이 없으므로 추천 사항은 지속적으로 진행되는 사용자 상호 작용 집합을 기반으로 해야한다는 것입니다.

> Content-based 접근법을 말하는 것 같은데..

음악 도메인에서 추천 시스템의 시작은 사용자가 방금 듣거나 재생목록에 추가한 작은 트랙 리스트입니다.

실질적인 관련성으로 인해 세션 기반의 추천시스템 문제가 최근 몇년간 주목받고 있습니다.

기술적으로 다양한 방식이 제안되었고, 이러한 접근 방식들은 마르코프 체인, 분포 임베딩 및 DNN을 기반으로하는 복잡한 계산식에 의존하거나 수학적 최적화 문제로 인코딩됩니다.

그러나 최근의 연구에 따르면 전자 상거래 및 음악 추천을 포함한 일부 응용분야에서 K-NN을 기반으로 하는 간단한 방법이 높은 정확도로 이어질 수 있음을 발견했습니다.

복잡한 방법은 일반적으로 이런 간단한 방법에 비해 성능이 뛰어나지만, 성능 차이가 그리 크지는 않습니다.

이 논문에서는 하이브리드 세션 기반 음악 추천 방법을 제시하고, 단순한 방법임에도 불구하고 좋은 퍼포먼스를 보입니다.

일반적으로 예측 정확도, 즉 사용자가 좋아하는 트랙을 식별할 수 있는 것은 음악 추천 시스템의 인식된 품질과 가치에 기여할 수 있는 몇 가지 요소중 하나 일 뿐입니다.

이전 연구에서 알 수 있듯이 아티스트의 다양성, 음악적 균질성, 트랙 간 전환, 신선도 및 일반적인 인기도 등 추천에 대한 사용자의 인식에 영향을 줄 수 있는 여러가지 측면들이 존재합니다.

따라서 우리와 같은 방법이 비교적 낮은 컴퓨팅 비용을 통한 경쟁력 있는 정확도로 이어지므로, 많은 실제 응용 분야에서 실행 가능한 알고리즘이 될 수 있다고 생각합니다.

## Problem Description

<hr>

### Computational Tasks

RecSys Challenge 2018의 컴퓨팅 문제는 특정 유형의 음악 추천, 즉 재생 목록 연속 문제와 관련이 있습니다.

재생 목록의 일부에 대한 특정 유형의 정보가 제공되면, 추천 작업은 리스트에 추가할 수 잇는 트랙 목록을 생성하는 것입니다.

다음 몇가지 유형의 정보를 추천을 위해 사용할 수 있습니다.

a) 재생 목록의 제목, 설명 및 팔로워 수와 같은 메타데이터

b) 시드트랙의 집합(재생목록에 미지 존재하는 트랙들)

c) 아티스트, 앨범 및 재생목록의 각 트랙 위치와 같은 트랙에 대한 메타데이터

이 챌린지에서 문제 설정은 개인화를 위한 장기 사용자 프로필이 없기 때문에 기존의 "Matrix completion" 와는 상당히 다릅니다.

대신 컴퓨팅 작업은 일련의 이전 트랙이 주어진 적절한 음악 트랙 집합을 결정하는 것입니다.

이 시나리오의 구체적인 챌린지는 아래와 같이 요약할 수 있습니다.

- **Cold start.** 재생 목록의 일부를 계속하려면 재생 목록의 제목(또는 재생 목록의 제목 & 첫번째 트랙)만 사용할 수 있습니다. 이러한 경우 일바적으로 사용되는 collaborative 기반의 테크닉을 직접 적용할 수 없습니다.
- **No long-term or user information.** 개인 정보 보호법에 의해 사용자의 이름이 데이터 셋에서 제거되므로 사용자의 장기적인 청취 행동을 기반으로하는 개인화된 기술을 적용할 수 없습니다.

### Data

<hr>

챌린지를 위해 Spotify에서 제공한 주요 데이터 셋은 재생 목록 타이틀, 트랙 목록 및 기타 메타 데이터를 포함한 100만개의 재생목록으로 구성됩니다.

아래 테이블은 각각 트랙과 재생 목록에 대한 메타 데이터의 특징을 보여줍니다.

데이터 셋은 MPD(Million Playlist Dataset)이라 부릅니다.

<img src = "https://py-tonic.github.io/images/enn/1.PNG">

또한 Spotify는 챌린지 참가자에게  특정 수의 트랙이 숨겨진 10,000개의 재생목록으로 구성된 테스트 혹은 "경쟁"데이터 셋을 제공했습니다.

10,000개의 재생 목록은 Table.2에 표시된 것 처럼 10개의 특정 하위 작업 중 하나에 할당되었습니다.

### Evaluation Procedure

<hr>

이번 RecSys Challenge는 오프라인 실험으로 설계되었으며 참가자들은 "main"과 "creative"두 가지 트랙을 제출해야합니다.

"main"트랙은 추가 데이터를 사용할 수 없고, "creative"는 퍼포먼스 향상을 위해 외부 데이터를 사용하여 추천 품질을 향상 시킬 수 있습니다.

경쟁 중에 참가자는 "main" 및 "creative" 트랙 모두에 대해 경쟁 데이터 셋의 재생 목록에 각각 500개의 트랙으로된 재생 목록을 제출할 수 있습니다.

<img src = "https://py-tonic.github.io/images/enn/2.PNG">

## Technical Approach

<hr>

트랙이 포함된 재생 목록의 경우 여러가지 확립된 기술을 결합하여 추천 목록과 순위를 결정했습니다.

구체적으로, 다음 섹션에서 보다 상세히 설명하게 될 item-based Collaborative filtering, K-NN기술 및 implicit feedback Matrix Factorization 접근법을 포함합니다. 

이름만 알려진 다른 재생 목록의 경우 두 가지 간단한 문자열 일치 전략을 사용합니다.

개별 방법 혹은 추천 시스템은 각각 시드 트랙 수와 재생 목록 이름의 발생에 따라 가중치 조합 및 다른 전략 간의 전환을 기반으로하는 하이브리드 방식으로 최종 결합되었습니다.

### Track-based Approaches

<hr>

우리는 후보 트랙 순위 목록을 결정하기 위해 다음의 트랙 기반 방법을 적용 및 커스터마이징 했습니다.

**Item-based Collaborative Filtering(ITEM-CF).** 기존의 item-to-item 접근 방식은 개념적으로 단순하지만 우수한 성능을 발휘하고 확장성이 뛰어나기 때문에 실제로 사용되는 경우가 많습니다.

하이브리드 방식에 사용된 item-cf 방법은 일반적으로 개별 item 유사성을 기반으로 하지만 여전히 재생 목록의 모든 지정된 시드 트랙을 고려합니다.

두 item 사이의 유사성은 평소와 같이 다른 세션에서 해당 항목의 발생 횟수에 의해 결정됩니다.

구현 측면에서, 각 트랙은 모든 재생 목록에서 binary vector로 표현됩니다.

즉, 특정 재생 목록의 엔트리는 item이 포함되어 있으면 1 아니면 0으로 설정됩니다.

따라서, 트랙 사이의 유사도는 계산될 수 있고, 예를 들어 코사인 유사도를 결정하고, 단일 트랙에 대한 추천은 유사도에 의해 정렬된 가장 유사한 k개의 최상위 트랙에 의해 형성됩니다.

item co-occurrences를 기반으로 하는 접근 방식은 상대적으로 인기가 높은 편향으로 이어질 수 있습니다.

기술의 향상으로 우리는 $idf(t) = log(\frac{\vert P\vert}{\vert P_t \vert})$ 인 모든 재생목록에 관하여 모든 트랙에 대한 IDF를 계산합니다. $P$는 모든 (학습) 재생 목록의 집합이고 $P_t$는  트랙 $t$를 포함하는 재생 목록 집합입니다.

그런 다음 가중치가 부여된 각 단일 시드 트랙에 대한 추천을 해당 트랙의 IDF와 결합하여 최종 리스트가 결정됩니다.

위를 통해서 재생 목록에 덜 인기있는 트랙이 더 중요해져 실험에서 정확도가 향상 되었습니다.

> Efficient K-NN 논문에서도 나온 내용인데 서로 다른 두 가지 플레이리스트가 unique한 트랙을 공유하는 경우 인기도가 높은 트랙을 공유할 때 보다 유사도가 더 높다고 볼 수 있다는 얘기인 것 같음

**Session-based Nearest Neighbors(S-KNN).** 짧은 재생 목록에서 추천하는 것은 

전자 상거래 브라우징 세션을 시작할 때 제안을 제공하는 문제와 비교할 수 있기 때문에(무슨 예시인지 잘 안와닿는데..) 이전의 전자 상거래 및 음악 도메인에 대한 유망한 결과를 가져오는 세션 기반 추천 방법에 의존했습니다.

s-knn 방식은 각 시드 트랙에 대한 추천을 개별적으로 생성하지 않습니다.

대신 전체 재생 목록을 고려하여 학습용 데이터에서 가장 유사한 재생 목록을 검색합니다. 그런 다음 주변 재생 목록의 트랙에 순위를 지정하여 추천 목록을 만듭니다.

먼저, 아이템 공간에 대해 binary vector에 적절한 유사도 측정을 적용하여 주어진 재생 목록 $p$에 대해 $k$개의 가장 유사한 재생 목록 $N_p$를 결정합니다. 

즉 아이템이 재생 목록에 포함되어 있으면 특정 트랙의 인덱스가 1로 설정되고 그렇지 않으면 0으로 설정됩니다.

재생목록 $p$, 이웃 $N_p$ 및 2개의 재생 목록 $p1,p2$에 대한 유사성 함수 $sim(p1,p2)$를 고려 할 때 각 트랙에 대한 순위는 다음과 같이 결정됩니다.

$rank_{s-knn}(t,p) = \sum_{n \in N_p}sim(p,n) *1_n(t)*idf(t) \tag{1}$

여기서 $1_n(i)$는 이웃 $n$이 트랙 $t$를 포함하면 1을 리턴하고 그렇지 않으면 0을 리턴하는 indicator function 입니다.

다시말해서 우리의 목표는, 인기가 적은(unique) 아이템에 대한 중요성을 높이고, 일반적으로 이 방법의 인기의 편차를 줄이기 위해 트랙의 IDF값을 순위 계산에 추가했습니다.

이웃의 크기가 2000인 코사인 유사도 측정을 적용하면 실험에서 좋은 결과를 얻었습니다.

현재 재생 목록 $p$가 주어지면, 기존 재생 목록 전체를 스캔하기에는 실제로 너무 많은 시간이 소요될 수 있습니다.

우리의 구현은 미리 계산된 메모리 내 인덱스 데이터 구조와 주변 샘플링에 의존하여 빠른 예측 시간을 보장합니다.

> 자세한 내용은 아래 페이퍼에 나와있습니다.
>
> [When Recurrent Neural Networks meet the Neighborhood for Session Based Recommendation]( https://dl.acm.org/doi/epdf/10.1145/3109859.3109872 )

첫 째, 재생 목록은 현재 재생 목록에서 하나 이상의 트랙을 포함하는 경우에만 인접 후보로 간주됩니다.

둘 째, 가장 최근에 편집한 $m$개의 재생 목록에 초점을 맞춘 샘플링 파라미터 $m$을 소개합니다.

최종 제출 시 사용 가능한 모든 정보를 활용하기 위해  이 샘플링을 적용하지 않았습니다.

다른 제출물에서는 $m$ = 5000 정도의 재생 목록만 고려해도 정확도가 크게 저하되지는 않았습니다.

**IDF Extension(IDF-KNN).** s-knn의 우선순위 계산에 IDF 값을 추가하면 정확도가 향상되므로 재생 목록 유사성 점수를 계산할 때 TF-IDF 개념을 포함하는 방법의 대안을 구현했습니다.

 여기서는 재생 목록을 아이템 공간에서 binary vector로 표시하는 대신 약간의 수정된 TF-IDF 벡터로 표시합니다.

각 트랙과 재생 목록에 대한 TF-IDF 점수를 계산하기 위해 TF를 약간 조정하여 표준 공식 $tfidf(p,t) = tf(p,t)*idf(t)$를 사용합니다.

재생 목록 $p$및 트랙$t$의 경우 TF 부분은 다음과 같이 계산됩니다.

$tf(p,t) = \frac{1}{\vert p \vert + s} \tag{2}$

각 트랙은 재생 목록에 한 번만 나타나야하기 때문에 분자가 1이고,

$s$는 트랙 수가 적은 재생 목록을 처리하기 위해 도입된 파라미터 입니다.

> tf(p,t): 특정 플레이리스트 p에서 특정 트랙 t의 등장 횟수.
>
> 분모는 그럼 플레이리스트의 크기 == 총 트랙의 개수 ..?

이 파라미터는 트랙 수가 적은 재생 목록에 TF 가중치가 매우 높은 것을 방지합니다.

실험을 통해 대회의 데이터에는 $s=50$일 때 가장 잘 작동합니다.

기술적인 재생 목록의 representation은 기존의 s-knn공식과 다르지만 순위는 여전히 매우 비슷한 방식으로 계산됩니다.

$rank_{IDF-KNN}(t,p) = \sum_{n \in N_p}sim(p,n)*1_n(t) \tag{3}$

여기서 거리는 코사인 유사도 측정으로 다시 결정됩니다.

반면 식3의 $idf(p,t)$항은 생략 되었으며 $k=1000$인 경우 더 적은 수의 이웃이 최상의 결과를 보였습니다.

**Matrix Factorization(ALS-MF).** 하이브리드의 마지막 트랙 기반 구성 요소로서 널리 사용되는 MF(Matrix Factorization)기술을 포함시켰습니다.

우리의 설정에서 재생 목록은 유저에 대응하고 포함된 트랙은 implicit feedback signal로 구성되는 sparse binary user-item "rating" matrix 입니다.

유저 혹은 재생 목록에 대한 아이템의 순위를 지정하기 위해 두가지 implicit feedback MF기술, 특히 BPR(Bayesian Personalized Ranking) 및 최적화 된 ALS 기반 방법을 테스트했습니다.

ALS 기반 방법을 적용할 때 10회 반복에서 300개의 latent factor와 정규화 파라미터를 0.08로 적용할 때 좋은 결과를 얻었습니다.

그러나 새로 생성된 재생 목록에 대한 추천을 제공해야 하므로 상황은 MF기술에 대한 유저 cold-start 시나리오에 매핑됩니다.( However, due to the fact that we have to provide recommendations for a newly created playlist, the situation maps to a user cold-start scenario for the MF techniques )

재생 목록의 시드 트랙에 해당하는 모든 item latent factor로 부터 user-latent factor를 구성하여 이 문제를 극복했습니다.

모든 item factor의 평균을 사용하는 대신, 우리는 덜 인기있는 트랙을 강조하기 위해 IDF 가중치를 통합합니다.

따라서, 트랙 $t$의 랭크는 다음과 같이 계산됩니다.

$rank_{ALS-MF}(t,p) = TL_t*(\frac{1}{\sum_{s \in p \ idf(s)}} \sum\limits_{s \in p}idf(s)*TL_s) \tag{4}$

여기서 TL은 트랙의 latent factor이고, 후자는 재생 목록$p$에 대한 모든 factor의 가중 산술 평균으로 IDF와 결합합니다.

그런 다음 최종 순위 점수는 내적으로 계산됩니다.

우리의 실험은 이 절차를 적용할 때 기존의 MF에 비해 정확도가 크게 감소하지 않았습니다.

### Name-based Approaches

<hr>

트랙 기반 접근법 외에도, 우리는 특별 추천 시나리오를 위해 두 가지 간단한 이름 기반 접근법을 제시합니다.

여기서 우리는 재생 목록 이름만 알고 있지만 추천을 기반으로 하는 단일 시드 트랙은 없습니다.

**String Matching(STRING-MATCH).** 문자열 일치를 사용하여 재생 목록 이름을 기반으로 적절한 트랙을 찾기 위한 간단한 접근 방식을 구현했습니다.

MPD에서 가장 유사한 이름을 가진 모든 재생 목록을 수집하고, 해당 재생목록의 트랙을 내림차순으로 정렬하는 것이 좋습니다.

구현 측면에서 품질을 개선하고 보다 유연한 접근 방식을 만들기 위해 먼저 nltk로 재생 목록 이름을 사전 처리 합니다.

특히 문자열을 토큰화하고 Porter 형태소 분석 알고리즘을 적용했습니다.

알려진 재생 목록 이름 집합에서 정확이 일치하는 항목이 없으면 이름을 Levenshtein 거리에 따라 가장 유사한 알려진 이름으로 바꿉니다.

**Title Factorization(TITLE-MF).** 두 번째 이름 기반 기술인 title-mf는 문자열 일치를 확장하고 MF기술을 기반으로 유사한 이름을 가진 재생 목록의 트랙을 포함하는 것을 목표로 합니다.

또한 nltk 툴킷은 이름을 사전처리 할 때 사용됩니다.

동일한 ALS기반 접근 방식으로 행렬을 인수 분해 한 후 이름의 latent vector를 사용하여 재생 목록에 포함된 트랙과 유사한 이름을 찾을 수 있습니다.

예측 단계에서 **string-match**와 대조적으로 하나의 이름 대신 k개의 가장 유사한 이름을 사용합니다.

각 유사한 이름에 대해 트랙 발생 횟수를 세고 이름 유사성을 곱합니다.

마지막으로 가중 카운트는 개별 점수를 합산하여 단일 추천 목록에 결합됩니다.

### Hybridization

<hr>

권장 사항을 개선하기 위해서 세 가지 유형의 하이브리드 전략을 사용하여 앞에서 설명한 모든 방법을 결합했습니다.

Fig.1은 전체 아키텍처의 개요를 보여줍니다.

<img src = "https://py-tonic.github.io/images/enn/4.PNG">

**Filling**: 최종 추천 목록을 생성하기 위해 일부 경우에 사용한 하이브리드의 첫 번째 유형은 "채우기" 하이브리드 입니다.

**"String-match"** 방식이 추천 트랙(500개를 못 채울 때)을 충분히 반영하지 못할 때 마다 목록은 train data에서 가장 인기있는 트랙으로 채워졌습니다.

**Weighted**: 이 하이브리드 방식은 순위 점수를 기반으로 두 가지 이상 방법의 추천 목록을 특정 가중치와 결합합니다.

이러한 점수 규모가 크게 다를 수 있으므로 모든 점수는 상위 500개의 트랙에 대해 min-max normalized 되었습니다.

또한 LARGE1 샘플의 가중치를 최적화했습니다.

모든 이름 기반 및 모든 트랙 기반 방법의 개별 조합 외에도, 이 두가지 조합의 가중치 하이브리드를 만들었으며, 이름과 하나의 단일 시드 트랙이 있는 재생 목록의 성능이 우수했습니다.

**Switching**: 스위칭 하이브리드는 일반적으로 특정 상황에 따라 다른 기술이나 모델간에 변경됩니다.

이 시나리오에서는 context가 시드 트랙 수로 제공됩니다.

name-only 재생 목록의 경우 이름 기반 기술의 가중치 하이브리드를 사용했습니다.

시드 트랙이 두 개 이상인 경우 모든 트랙 기반 방법의 가중치 하이브리드 방식을 적용했습니다.

마지막으로 하나의 시드 트랙과 재생 목록 이름이 있을 때 두 하이브리드 가중치 조합이 사용되었습니다.

## Results And Observations

<hr>

첫 째, 트랙 기반 기술과 관련하여 idf-knn은 대부분의 샘플에서 가장 경쟁력있는 방법으로 구별될 수 있습니다.

item-cf는 일반적으로 sknn보다 더 정확하지만 후자의 방법은 항목을 더 나은 방식으로 순위를 매기는데 일반적으로 NDCG및 Click meteric에서 향상됩니다.

als-mf는 모든 metric과 관련하여 전반적으로 최악의 방법입니다.

그러나 가중 하이브리드에서 서로 다른 방법을 결합할 때 MF방식이 포함되면 성능이 향상됩니다.

하이브리드 접근법은 모든 방법의 장점을 활용합니다.

대부분의 경우 모든 성능 값이 증가합니다. Click rank에 대해서만 s-knn은 작은 샘플에 대한 최선의 방법으로 남아있습니다.

둘 째, 이름 기반 접근 방식과 관련하여 title-mf는 항상 NDCG와 정밀 metric을 개선했습니다.

동시에 Click metric은 일반적으로 크게 악화되었습니다.

예를 들어, LARGE1 샘플의 경우 NDCG 및 정밀도가 4% 개선되었지만 Click metric 측면에서 2%감소했습니다.



 

## Reference

<hr>

[Effective NN]( https://web-ainf.aau.at/pub/jannach/files/Workshop_RecSys_Challenge_2018.pdf )