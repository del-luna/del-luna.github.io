---
layout: post
title: Effective Nearest-Neighbor Music Recommendations
author: Jaeheon Kwon
categories: Papers
tags: [recommendation,knn]
---

#  Effective Nearest-Neighbor Music Recommendations  

## Abstract

다음 트랙이 재생목록에 포함되거나 포함되도록 자동으로 추천하는 시스템은 최신 음악 플랫폼에서 일반적인 기능입니다.

이에 따라, 추천할 트랙을 결정하기 위한 다양한 알고리즘이 연구를 통해 제안되었습니다.

그 중에서 높은 성능을 보이는 것들은 종종 개념적으로 복잡한 테크닉을 기반으로 하며, 상당한 컴퓨팅 리소스 혹은 GPU같은 특수 목적 하드웨어를 필요로합니다.

그러나 최근 연구에 따르면, Nearest-Neighbor를 기반으로 하는 개념적으로 더 간단한 기법은 실제로 위의 기술들의 대안이 될 수 있음이 밝혀졌습니다.

이 논문에서는 RecSys 2018 Challenge에서 평가된 다음 트랙 추천을 위한 하이브리드 테크닉에 대해 설명합니다.

K-NN, standard matrix factorization, small set of heuristics를 조합하여 "creative" 트랙에서 3위, "main"트랙에서 7위를 달성했습니다.

## Introduction

자동 추천기능을 지원하는 것은 온라인 음악 플랫폼들의 공통 기능입니다.

장기적인 환경 설정을 기반으로하며 사용자가 새로운 트랙이나 아티스트를 찾도록 돕기위한 추천 시스템 외에도 다음 트랙을 추천하는 것은 이러한 플랫폼에서 중요한 역할을 합니다.

문제 설정의 측면에서 다음 트랙을 추천하는 것은 종종 세션 기반의 추천 시나리오의 특성을 공유합니다.( In terms of the problem setting, these next-track recommendations often share characteristics of session-based recommendation scenarios )

이 시나리오의 특징은 사용 가능한 장기 환경 설정 프로필이 없으므로 추천 사항은 지속적으로 진행되는 사용자 상호 작용 집합을 기반으로 해야한다는 것입니다.

> Content-based 접근법을 말하는 것 같은데..

음악 도메인에서 추천 시스템의 시작은 사용자가 방금 듣거나 재생목록에 추가한 작은 트랙 리스트입니다.

실질적인 관련성으로 인해 세션 기반의 추천시스템 문제가 최근 몇년간 주목받고 있습니다.

기술적으로 다양한 방식이 제안되었고, 이러한 접근 방식들은 마르코프 체인, 분포 임베딩 및 DNN을 기반으로하는 복잡한 계산식에 의존하거나 수학적 최적화 문제로 인코딩됩니다.

그러나 최근의 연구에 따르면 전자 상거래 및 음악 추천을 포함한 일부 응용분야에서 K-NN을 기반으로 하는 간단한 방법이 높은 정확도로 이어질 수 있음을 발견했습니다.

복잡한 방법은 일반적으로 이런 간단한 방법에 비해 성능이 뛰어나지만, 성능 차이가 그리 크지는 않습니다.

이 논문에서는 하이브리드 세션 기반 음악 추천 방법을 제시하고, 단순한 방법임에도 불구하고 좋은 퍼포먼스를 보입니다.

일반적으로 예측 정확도, 즉 사용자가 좋아하는 트랙을 식별할 수 있는 것은 음악 추천 시스템의 인식된 품질과 가치에 기여할 수 있는 몇 가지 요소중 하나 일 뿐입니다.

이전 연구에서 알 수 있듯이 아티스트의 다양성, 음악적 균질성, 트랙 간 전환, 신선도 및 일반적인 인기도 등 추천에 대한 사용자의 인식에 영향을 줄 수 있는 여러가지 측면들이 존재합니다.

따라서 우리와 같은 방법이 비교적 낮은 컴퓨팅 비용을 통한 경쟁력 있는 정확도로 이어지므로, 많은 실제 응용 분야에서 실행 가능한 알고리즘이 될 수 있다고 생각합니다.

## Problem Description

### Computational Tasks

RecSys Challenge 2018의 컴퓨팅 문제는 특정 유형의 음악 추천, 즉 재생 목록 연속 문제와 관련이 있습니다.

재생 목록의 일부에 대한 특정 유형의 정보가 제공되면, 추천 작업은 리스트에 추가할 수 잇는 트랙 목록을 생성하는 것입니다.

다음 몇가지 유형의 정보를 추천을 위해 사용할 수 있습니다.

a) 재생 목록의 제목, 설명 및 팔로워 수와 같은 메타데이터

b) 시드트랙의 집합(재생목록에 미지 존재하는 트랙들)

c) 아티스트, 앨범 및 재생목록의 각 트랙 위치와 같은 트랙에 대한 메타데이터

이 챌린지에서 문제 설정은 개인화를 위한 장기 사용자 프로필이 없기 때문에 기존의 "Matrix completion" 와는 상당히 다릅니다.

대신 컴퓨팅 작업은 일련의 이전 트랙이 주어진 적절한 음악 트랙 집합을 결정하는 것입니다.

이 시나리오의 구체적인 챌린지는 아래와 같이 요약할 수 있습니다.

- **Cold start.** 재생 목록의 일부를 계속하려면 재생 목록의 제목(또는 재생 목록의 제목 & 첫번째 트랙)만 사용할 수 있습니다. 이러한 경우 일바적으로 사용되는 collaborative 기반의 테크닉을 직접 적용할 수 없습니다.
- **No long-term or user information.** 개인 정보 보호법에 의해 사용자의 이름이 데이터 셋에서 제거되므로 사용자의 장기적인 청취 행동을 기반으로하는 개인화된 기술을 적용할 수 없습니다.

### Data

챌린지를 위해 Spotify에서 제공한 주요 데이터 셋은 재생 목록 타이틀, 트랙 목록 및 기타 메타 데이터를 포함한 100만개의 재생목록으로 구성됩니다.

아래 테이블은 각각 트랙과 재생 목록에 대한 메타 데이터의 특징을 보여줍니다.

데이터 셋은 MPD(Million Playlist Dataset)이라 부릅니다.

![1](C:\Users\illus\OneDrive\바탕 화면\enn\1.PNG)

또한 Spotify는 챌린지 참가자에게  특정 수의 트랙이 숨겨진 10,000개의 재생목록으로 구성된 테스트 혹은 "경쟁"데이터 셋을 제공했습니다.

10,000개의 재생 목록은 Table.2에 표시된 것 처럼 10개의 특정 하위 작업 중 하나에 할당되었습니다.

### Evaluation Procedure

이번 RecSys Challenge는 오프라인 실험으로 설계되었으며 참가자들은 "main"과 "creative"두 가지 트랙을 제출해야합니다.

"main"트랙은 추가 데이터를 사용할 수 없고, "creative"는 퍼포먼스 향상을 위해 외부 데이터를 사용하여 추천 품질을 향상 시킬 수 있습니다.

경쟁 중에 참가자는 "main" 및 "creative" 트랙 모두에 대해 경쟁 데이터 셋의 재생 목록에 각각 500개의 트랙으로된 재생 목록을 제출할 수 있습니다.

 ![2](C:\Users\illus\OneDrive\바탕 화면\enn\2.PNG)

## Technical Approach

트랙이 포함된 재생 목록의 경우 여러가지 확립된 기술을 결합하여 추천 목록과 순위를 결정했습니다.

구체적으로, 다음 섹션에서 보다 상세히 설명하게 될 item-based Collaborative filtering, K-NN기술 및 implicit feedback Matrix Factorization 접근법을 포함합니다. 

이름만 알려진 다른 재생 목록의 경우 두 가지 간단한 문자열 일치 전략을 사용합니다.

개별 방법 혹은 추천 시스템은 각각 시드 트랙 수와 재생 목록 이름의 발생에 따라 가중치 조합 및 다른 전략 간의 전환을 기반으로하는 하이브리드 방식으로 최종 결합되었습니다.

### Track-based Approaches

우리는 후보 트랙 순위 목록을 결정하기 위해 다음의 트랙 기반 방법을 적용 및 커스터마이징 했습니다.

**Item-based Collaborative Filtering(ITEM-CF).** 기존의 item-to-item 접근 방식은 개념적으로 단순하지만 우수한 성능을 발휘하고 확장성이 뛰어나기 때문에 실제로 사용되는 경우가 많습니다.

하이브리드 방식에 사용된 item-cf 방법은 일반적으로 개별 item 유사성을 기반으로 하지만 여전히 재생 목록의 모든 지정된 시드 트랙을 고려합니다.

두 item 사이의 유사성은 평소와 같이 다른 세션에서 해당 항목의 발생 횟수에 의해 결정됩니다.

구현 측면에서, 각 트랙은 모든 재생 목록에서 binary vector로 표현됩니다.

즉, 특정 재생 목록의 엔트리는 item이 포함되어 있으면 1 아니면 0으로 설정됩니다.

따라서, 트랙 사이의 유사도는 계산될 수 있고, 예를 들어 코사인 유사도를 결정하고, 단일 트랙에 대한 추천은 유사도에 의해 정렬된 가장 유사한 k개의 최상위 트랙에 의해 형성됩니다.

item co-occurrences를 기반으로 하는 접근 방식은 상대적으로 인기가 높은 편향으로 이어질 수 있습니다.

기술의 향상으로 우리는 $idf(t) = log(\frac{\vert P\vert}{\vert P_t \vert})$ 인 모든 재생목록에 관하여 모든 트랙에 대한 IDF를 계산합니다. $P$는 모든 (학습) 재생 목록의 집합이고 $P_t$는  트랙 $t$를 포함하는 재생 목록 집합입니다.

그런 다음 가중치가 부여된 각 단일 시드 트랙에 대한 추천을 해당 트랙의 IDF와 결합하여 최종 리스트가 결정됩니다.

위를 통해서 재생 목록에 덜 인기있는 트랙이 더 중요해져 실험에서 정확도가 향상 되었습니다.

> Efficient K-NN 논문에서도 나온 내용인데 서로 다른 두 가지 플레이리스트가 unique한 트랙을 공유하는 경우 인기도가 높은 트랙을 공유할 때 보다 유사도가 더 높다고 볼 수 있다는 얘기인 것 같음

**Session-based Nearest Neighbors(S-KNN).** 짧은 재생 목록에서 추천하는 것은 

전자 상거래 브라우징 세션을 시작할 때 제안을 제공하는 문제와 비교할 수 있기 때문에(무슨 예시인지 잘 안와닿는데..) 이전의 전자 상거래 및 음악 도메인에 대한 유망한 결과를 가져오는 세션 기반 추천 방법에 의존했습니다.

s-knn 방식은 각 시드 트랙에 대한 추천을 개별적으로 생성하지 않습니다.

대신 전체 재생 목록을 고려하여 학습용 데이터에서 가장 유사한 재생 목록을 검색합니다. 그런 다음 주변 재생 목록의 트랙에 순위를 지정하여 추천 목록을 만듭니다.

