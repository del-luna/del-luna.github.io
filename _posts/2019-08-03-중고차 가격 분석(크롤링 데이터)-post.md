---
layout: post
title: 중고차 가격 분석(with 크롤링 데이터)
author: Jaeheon Kwon
categories: Ai
tags: [regression,keras]
---
캐글의 중고차 분석을 경험삼아 직접 크롤링한 데이터를 이용하여 중고차 가격 예측을 해보자.

```python
import pandas as pd

import matplotlib.pyplot as plt
import numpy as np
from sklearn import datasets, linear_model, preprocessing, svm
from sklearn.preprocessing import StandardScaler, Normalizer
import math
import matplotlib
import seaborn as sns

%matplotlib inline
```

```python
def category_values(dataframe, categories):
    for c in categories:
        print('\n', dataframe.groupby(by=c)[c].count().sort_values(ascending=False))
        print('Nulls: ', dataframe[c].isnull().sum())
        
def plot_correlation_map( df ):
    corr = df.corr()
    _ , ax = plt.subplots( figsize =( 12 , 10 ) )
    cmap = sns.diverging_palette( 220 , 10 , as_cmap = True )
    _ = sns.heatmap(
        corr, 
        cmap = cmap,
        square=True, 
        cbar_kws={ 'shrink' : .9 }, 
        ax=ax, 
        annot = True, 
        annot_kws = { 'fontsize' : 12 }
    )
```

```python
df = pd.read_excel('C:\data\car_data.xlsx')
df.head()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>번호</th>
      <th>name</th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
      <th>accident</th>
      <th>brand</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>기아 K5 (10년~13년) 2.0 디럭스</td>
      <td>490</td>
      <td>2010.0</td>
      <td>158438</td>
      <td>확인불가</td>
      <td>기아</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>현대 YF 쏘나타 (09년~12년) Y20 CVVL 프리미어</td>
      <td>680</td>
      <td>2010.0</td>
      <td>117809</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>현대 그랜져TG 뉴 럭셔리 (08년~09년) Q270 럭셔리 기본형</td>
      <td>460</td>
      <td>2008.0</td>
      <td>94180</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>현대 싼타페(DM) (12년~15년) 4WD (2.0 e-VGT) 익스클루시브 기본형</td>
      <td>1600</td>
      <td>2014.0</td>
      <td>120044</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>쉐보레/대우 알페온 (10년~현재) EL240 디럭스</td>
      <td>1050</td>
      <td>2014.0</td>
      <td>63587</td>
      <td>확인불가</td>
      <td>쉐보레/대우</td>
    </tr>
  </tbody>
</table>

</div>



```python
df.info()
```

```
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 33391 entries, 0 to 33390
Data columns (total 7 columns):
번호          33391 non-null int64
name        33391 non-null object
price       33391 non-null int64
year        33389 non-null float64
mileage     33391 non-null int64
accident    33391 non-null object
brand       33391 non-null object
dtypes: float64(1), int64(3), object(3)
memory usage: 1.8+ MB
```



```python
df['price']=df['price'].astype('float')
df['year']=df['year'].astype('float')
df['mileage']=df['mileage'].astype('float')
```

```python
df.info()
```

```
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 33391 entries, 0 to 33390
Data columns (total 7 columns):
번호          33391 non-null int64
name        33391 non-null object
price       33391 non-null float64
year        33389 non-null float64
mileage     33391 non-null float64
accident    33391 non-null object
brand       33391 non-null object
dtypes: float64(3), int64(1), object(3)
memory usage: 1.8+ MB
```



```python
df.describe()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>번호</th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>33391.000000</td>
      <td>33391.000000</td>
      <td>33389.000000</td>
      <td>3.339100e+04</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>16696.652990</td>
      <td>946.694289</td>
      <td>2015.381713</td>
      <td>3.839297e+04</td>
    </tr>
    <tr>
      <th>std</th>
      <td>9639.126457</td>
      <td>1084.334903</td>
      <td>11.511122</td>
      <td>1.038123e+05</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>8351.500000</td>
      <td>413.500000</td>
      <td>2014.000000</td>
      <td>5.195000e+02</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>16699.000000</td>
      <td>610.000000</td>
      <td>2016.000000</td>
      <td>8.520000e+03</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>25046.500000</td>
      <td>1090.000000</td>
      <td>2018.000000</td>
      <td>6.000000e+04</td>
    </tr>
    <tr>
      <th>max</th>
      <td>33394.000000</td>
      <td>73500.000000</td>
      <td>2088.000000</td>
      <td>1.547896e+07</td>
    </tr>
  </tbody>
</table>

</div>



```python
df = df[df.year != 0]
df = df[df.price != 0]
df.describe()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>번호</th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>33383.000000</td>
      <td>33383.000000</td>
      <td>33381.000000</td>
      <td>3.338300e+04</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>16696.724381</td>
      <td>946.342060</td>
      <td>2015.442797</td>
      <td>3.838929e+04</td>
    </tr>
    <tr>
      <th>std</th>
      <td>9639.087077</td>
      <td>1079.699078</td>
      <td>3.292629</td>
      <td>1.038167e+05</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>10.000000</td>
      <td>1993.000000</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>8353.500000</td>
      <td>414.500000</td>
      <td>2014.000000</td>
      <td>5.185000e+02</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>16699.000000</td>
      <td>610.000000</td>
      <td>2016.000000</td>
      <td>8.520000e+03</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>25046.500000</td>
      <td>1090.000000</td>
      <td>2018.000000</td>
      <td>6.000000e+04</td>
    </tr>
    <tr>
      <th>max</th>
      <td>33394.000000</td>
      <td>73500.000000</td>
      <td>2088.000000</td>
      <td>1.547896e+07</td>
    </tr>
  </tbody>
</table>

</div>



```python
dedups = df.drop_duplicates(['name','price','year','mileage','accident','brand'])

dedups = dedups[
        (dedups.year <= 2019) 
      & (dedups.year >= 1993) 
      & (dedups.price >= 100) 
      & (dedups.price <= 50000)]

```

```python
print("-----------------\nData kept for analisys: %d percent of the entire set\n-----------------" % (100 * dedups['name'].count() / df['name'].count()))
```

```
-----------------
Data kept for analisys: 99 percent of the entire set
-----------------
```



```python
dedups.isnull().sum()
```



```
번호          0
name        0
price       0
year        0
mileage     0
accident    0
brand       0
dtype: int64
```



```python
dedups.describe()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>번호</th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>33321.000000</td>
      <td>33321.000000</td>
      <td>33321.000000</td>
      <td>3.332100e+04</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>16704.148825</td>
      <td>944.936196</td>
      <td>2015.454818</td>
      <td>3.832911e+04</td>
    </tr>
    <tr>
      <th>std</th>
      <td>9644.977245</td>
      <td>1003.692715</td>
      <td>3.244990</td>
      <td>1.038596e+05</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.000000</td>
      <td>100.000000</td>
      <td>1993.000000</td>
      <td>0.000000e+00</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>8348.000000</td>
      <td>415.000000</td>
      <td>2014.000000</td>
      <td>5.170000e+02</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>16730.000000</td>
      <td>610.000000</td>
      <td>2016.000000</td>
      <td>8.477000e+03</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>25062.000000</td>
      <td>1090.000000</td>
      <td>2018.000000</td>
      <td>6.000000e+04</td>
    </tr>
    <tr>
      <th>max</th>
      <td>33394.000000</td>
      <td>40900.000000</td>
      <td>2019.000000</td>
      <td>1.547896e+07</td>
    </tr>
  </tbody>
</table>

</div>



```python
dedups.drop(['번호'], axis='columns',inplace=True)
```

```python
dedups.head()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
      <th>accident</th>
      <th>brand</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>기아 K5 (10년~13년) 2.0 디럭스</td>
      <td>490.0</td>
      <td>2010.0</td>
      <td>158438.0</td>
      <td>확인불가</td>
      <td>기아</td>
    </tr>
    <tr>
      <th>1</th>
      <td>현대 YF 쏘나타 (09년~12년) Y20 CVVL 프리미어</td>
      <td>680.0</td>
      <td>2010.0</td>
      <td>117809.0</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>2</th>
      <td>현대 그랜져TG 뉴 럭셔리 (08년~09년) Q270 럭셔리 기본형</td>
      <td>460.0</td>
      <td>2008.0</td>
      <td>94180.0</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>3</th>
      <td>현대 싼타페(DM) (12년~15년) 4WD (2.0 e-VGT) 익스클루시브 기본형</td>
      <td>1600.0</td>
      <td>2014.0</td>
      <td>120044.0</td>
      <td>확인불가</td>
      <td>현대</td>
    </tr>
    <tr>
      <th>4</th>
      <td>쉐보레/대우 알페온 (10년~현재) EL240 디럭스</td>
      <td>1050.0</td>
      <td>2014.0</td>
      <td>63587.0</td>
      <td>확인불가</td>
      <td>쉐보레/대우</td>
    </tr>
  </tbody>
</table>

</div>



```python
labels = ['name','accident','brand']
les = {}

for l in labels:
    les[l] = preprocessing.LabelEncoder()
    #범주형 변수를 모델이 주입하기위해 labelEncoding을 해줌
    #범주형 변수를 정수로 매핑해줌
    
    les[l].fit(dedups[l])
    tr = les[l].transform(dedups[l]) 
    dedups.loc[:, l + '_feat'] = pd.Series(tr, index=dedups.index)

    #pd.Series는 값과 인덱스를 동시에 입력 가능하게해줌
    
labeled = dedups[ ['price','year','mileage'] + [x+"_feat" for x in labels]]
```

```python
plot_correlation_map(labeled)
labeled.corr()
```



<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

```
.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
```

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>year</th>
      <th>mileage</th>
      <th>name_feat</th>
      <th>accident_feat</th>
      <th>brand_feat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price</th>
      <td>1.000000</td>
      <td>0.079517</td>
      <td>0.054031</td>
      <td>-0.069929</td>
      <td>0.453974</td>
      <td>-0.065243</td>
    </tr>
    <tr>
      <th>year</th>
      <td>0.079517</td>
      <td>1.000000</td>
      <td>-0.365278</td>
      <td>-0.028681</td>
      <td>-0.502885</td>
      <td>-0.034684</td>
    </tr>
    <tr>
      <th>mileage</th>
      <td>0.054031</td>
      <td>-0.365278</td>
      <td>1.000000</td>
      <td>0.012846</td>
      <td>0.374662</td>
      <td>0.018494</td>
    </tr>
    <tr>
      <th>name_feat</th>
      <td>-0.069929</td>
      <td>-0.028681</td>
      <td>0.012846</td>
      <td>1.000000</td>
      <td>-0.012910</td>
      <td>0.976373</td>
    </tr>
    <tr>
      <th>accident_feat</th>
      <td>0.453974</td>
      <td>-0.502885</td>
      <td>0.374662</td>
      <td>-0.012910</td>
      <td>1.000000</td>
      <td>-0.007215</td>
    </tr>
    <tr>
      <th>brand_feat</th>
      <td>-0.065243</td>
      <td>-0.034684</td>
      <td>0.018494</td>
      <td>0.976373</td>
      <td>-0.007215</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>

</div>



<figure>
    <img src="https://py-tonic.github.io/images/used_car_predict_files/used_car_predict_15_1.png">
</figure>


```python
labeled.corr().loc[:,'price'].abs().sort_values(ascending=False)[1:]
```



```
accident_feat    0.453974
year             0.079517
name_feat        0.069929
brand_feat       0.065243
mileage          0.054031
Name: price, dtype: float64
```



```python
Y = labeled['price']
X = labeled.drop(['price'], axis='columns', inplace=False)


matplotlib.rcParams['figure.figsize'] = (12.0, 6.0)
prices = pd.DataFrame({"1. Before":Y, "2. After":np.log1p(Y)})
prices.hist()

Y = np.log1p(Y)
```

<figure>
    <img src="https://py-tonic.github.io/images/used_car_predict_files/used_car_predict_17_0.png">
</figure>



```python
from sklearn.linear_model import Ridge, RidgeCV, ElasticNet, Lasso, LassoCV, LassoLarsCV
from sklearn.model_selection import cross_val_score, train_test_split

#릿지 회귀를 사용하려는 것 같은데 규제가 있는 선형회귀라고 보시면 됩니다.

def cv_rmse(model, x, y):
    r = np.sqrt(-cross_val_score(model, x, y, scoring="neg_mean_squared_error", cv = 5))
    return r
#사이킷런의 교차검증은 매개변수에 보통사용하는 낮을수록 좋은 cost-function이 아닌
#클수록 좋은 utility function을 사용해요 그래서 평균제곱오차의 반댓값(즉 음숫값)을 계산하는
#neg_mean_squared_error 이러한 함수를 사용해요 그래서 -부호가 붙습니다.


# Percent of the X array to use as training set. This implies that the rest will be test set
test_size = .33

#Split into train and validation
X_train, X_val, y_train, y_val = train_test_split(X, Y, test_size=test_size, random_state = 3)
print(X_train.shape, X_val.shape, y_train.shape, y_val.shape)

r = range(2003, 2017)
km_year = 10000
```

```
(22325, 5) (10996, 5) (22325,) (10996,)
```



```python
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import GridSearchCV

#RandomForestRegressor 모델은 feature를 무작위로 선택해서 많은 decision tree를 만들고
#그 예측을 평균내는 방식으로 작동
 
rf = RandomForestRegressor()

param_grid = { "criterion" : ["mse"]
              , "min_samples_leaf" : [3]
              , "min_samples_split" : [3]
              , "max_depth": [10]
              , "n_estimators": [500]}

gs = GridSearchCV(estimator=rf, param_grid=param_grid, cv=2, n_jobs=-1, verbose=1)
gs = gs.fit(X_train, y_train)
```

```
Fitting 2 folds for each of 1 candidates, totalling 2 fits
```

```
[Parallel(n_jobs=-1)]: Using backend LokyBackend with 6 concurrent workers.
[Parallel(n_jobs=-1)]: Done   2 out of   2 | elapsed:    6.6s finished
```



```python
print(gs.best_score_)
print(gs.best_params_)
```

```
0.7413722429486044
{'criterion': 'mse', 'max_depth': 10, 'min_samples_leaf': 3, 'min_samples_split': 3, 'n_estimators': 500}
```



```python
bp = gs.best_params_
forest = RandomForestRegressor(criterion=bp['criterion'],
                              min_samples_leaf=bp['min_samples_leaf'],
                              min_samples_split=bp['min_samples_split'],
                              max_depth=bp['max_depth'],
                              n_estimators=bp['n_estimators'])
forest.fit(X_train, y_train)
# Explained variance score: 1 is perfect prediction
print('Score: %.2f' % forest.score(X_val, y_val))
```

```
Score: 0.75
```

