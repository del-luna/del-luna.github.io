---
layout: post
title: 알아두면 쓸데있는 신비한 파이썬팁
author: Jaeheon Kwon
categories: Python
tags: [tips]
---



## bool메소드는 구현되어 있지 않으면 \__len__()을 확인한다.



```python
class A:
    def __init__(self,x):
        self.x = x
        
    #def __bool__(self):
    #    return bool(self.x)
    
    def __len__(self):
        print('__len__ method is called')
        return len(self.x)
>>>a=A([1,2,3])
>>>bool(a)

__len__ method is called
True
```



## len()은 왜 메서드가 아닐까?

len()은 \__len__()을 호출한다.

```python
class A:
    def __init__(self, x):
        self.x = x
    def __len__(self): 
        print('__len__ method is called')
        return len(self.x)
>>>a = A([1,2,3])
>>>print(len(a))

__len__ method is called
```

len()함수는 클래스 인스턴스의 \_\_len__()이 구현되어 있는지 확인하고, return 유형과 값이 알맞는지 까지 체크한 뒤 최종적으로 정수의 값을 반환한다.

우선 귀도는 len(s)가 s.len()보다 읽기 쉽다고 한다.(마치 abs(n)과 같이 단항연산은 접두사 표기법이 직관적이다.)

그리고 각각의 시퀀스 객체에 대해 메서드로 정의되지 않고 len()이라는 함수로 모두 사용하는게 훨씬 더 실용적이다.

그러나 \_\_len\_\_을 지원 하는 이유는 다음과 같다.

앞서 len()을 사용하면 \__len__을 fallback으로 호출한다고 말했다. 이처럼 매직 메서드를 사용하면 사용자 정의 클래스에서 커스터마이징 하여 내장된 것 처럼 동작하는 객체를 'Pythonic'하게 만들 수 있다.

이를 내장 객체의 효율성과 언어의 일관성에서 어느정도 타협했다고 말한다.



## 리스트 컴프리헨션이 가능한 이유

파이썬에서는 [],{},()와 같은 시퀀스 객체를 정의하는 연산자 안에서 개행이 무시된다.

따라서 줄을 넘기기 위해 \\를 사용하지 않고도 여러 줄에 걸쳐서 리스트, 리스트 컴프리헨션 등을 작성할 수 있다.



## import dis

```python
import dis
>>>dis.dis('s[a]+=b')

  1           0 LOAD_NAME                0 (s)
              2 LOAD_NAME                1 (a)
              4 DUP_TOP_TWO
              6 BINARY_SUBSCR
              8 LOAD_NAME                2 (b)
             10 INPLACE_ADD
             12 ROT_THREE
             14 STORE_SUBSCR
             16 LOAD_CONST               0 (None)
             18 RETURN_VALUE
```

dis모듈을 사용해서 표현식에 대한 바이트코드를 확인할 수 있다.





## Key는 유용하다.

다음과 같은 리스트를 정렬한다고 한다. 어떻게 할것인가?

```python
x = [28,14,'28',5,'9','1',0,6,'23',19]
```



필자는 아래와 같은 방법을 생각했다.

```python
sorted([int(i)for i in x])
```

하지만 위 방법은 리스트 안의 자료형을 모두 int로 바꾸게 된다.



sorted, max, min과 같은 몇몇의 내장함수는 기준 값 (key)를 지정할 수 있다.

```python
sorted(x, key=int)
```

훨씬 간단한 방법으로 원본 객체를 보존하면서 정렬할 수 있다.





## Hashable?

수명 주기동안 결코 변하지 않는 해시값을 가지고 있고, 다른 객체와 비교가능하면 객체를 hashable이라고 말한다.

사용자 정의 자료형은 기본적으로 hashable이다. 객체의 해시값은 id를 이용해서 구하므로 모든 객체가 서로 다르기 때문이다. 객체가 자신의 내부 상태를 평가해서 \_\_eq_\_() 메서드를 직접 구현하는 경우에는 해시값 계산에 사용되는 속성이 모두 불변형일 때만 hashable이다.

불변형 객체(str,byte, 수치형)은 모두 hashable이고, tuple은 불변형이지만 내부 객체또한 모두 hashable해야 hashable이다. 다음 코드를 보자.

```python
>>>t1 = (1,2,(30,40))
>>>print(hash(t1))
>>>t2 = (1,2,[30,40])
>>>print(hash(t2))

8027212646858338501
TypeError: unhashable type: 'list'
```



## Flatten

중첩 리스트와 같은 형태를 Flatten해주는 방법은 여러가지가 있다.

[stackoverflow](https://stackoverflow.com/questions/952914/how-to-make-a-flat-list-out-of-list-of-lists)

여기에 상당히 다양한 방법들이 나와있는데,

기존에 내가 사용했던 방법은 이렇다.

```python
import itertools
list2d = [[1,2,3], [4,5,6], [7], [8,9]]
merged = list(itertools.chain(*list2d))
```



한 가지 센세이션했던 방법은 아래이다.

```python
>>> sum(l, [])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

그러나 위 방법은 상당히 비효율 적이라고 한다. 관심있다면 [여기](https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/)를 참고하자.